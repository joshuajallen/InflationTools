
#' Cashflow table generator 
#' 
#' @description Gernerates a table of cashflows for a fixed income instrument with regular cashflows, including
#'     the discounting fraction of each period 
#' 
#' @param maturity_date date, the date of the maturity ie final cashflow 
#' @param coupon numeric, the coupon in percent to be paid at regular intervals
#' @param payment_frequency numeric, the number of times per year the coupon is to be paid
#' @param ref_date date, the expected trade date, default to today
#' @param settle_convention numeric, the days until the instrument will be settled
#' @param day_count character, the day count convention of the instrument. Can currently only be \code{"ACT/ACT"}.
#'
#' @return a tibble of cashflows with discount periods
#' @export
#'
#' @examples
#' cashflow_table(as.Date("2023-02-21"), 0.1, 2)
#' 
#' 
cashflow_table <- function(maturity_date,
                           coupon,
                           payment_frequency,
                           ref_date = Sys.Date(),
                           settle_convention = 1,
                           day_count = "ACT/ACT"){
  
  
  cashflow_table <- tibble::enframe(jrvFinance::coupons.dates(settle = "2019-01-01",
                                                              mature = maturity_date,
                                                              freq = payment_frequency),
                                    value = "cashflow_date",
                                    name = NULL
  ) %>%
    dplyr::mutate(days_from_start = cashflow_date - min(cashflow_date),
                  cashflow_period_days = as.numeric(days_from_start - dplyr::lag(days_from_start, default = days_from_start[1]))) %>%
    dplyr::filter(cashflow_date > ref_date + settle_convention) %>%
    dplyr::select(-days_from_start) %>% 
    dplyr::mutate(unadjusted_interest = 1000000 * coupon / (100 * payment_frequency),
                  unadjusted_principal = dplyr::if_else(maturity_date == cashflow_date, 1000000, 0),
                  unadjusted_cashflow = unadjusted_interest + unadjusted_principal)
  
  if(day_count == "ACT/ACT"){
    
    cashflow_table <- cashflow_table %>%
      dplyr::mutate(period_numerator = as.numeric(cashflow_date - ref_date - settle_convention),
                    period_denominator = cashflow_period_days,
                    discount_period_fraction = (floor(period_numerator / period_denominator)) + (period_numerator[1] / period_denominator[1]))
  }else if(day_count == "NL/365"){
    futile.logger::flog.error(paste0("Day count method ", day_count, " is not currently supported as not in jrvFinance package. See cashflow_table function."))
  }else{
    futile.logger::flog.error(paste0("Day count method ", day_count, " is not currently supported. See cashflow_table function."))
  }
  
  return(cashflow_table)
  
}


#' Interpolate inflation for instrument cashflow 
#' 
#' @description For an instrument with regular cashflows, interpolate a projected (or realised) inflation curve to get the index
#'     values for the cashflow dates.  
#' 
#' @param cashflow_table data.table, table of cashflows and discount periods, can be generated by \link[InflationTools]{cashflow_table}
#' @param projected_inflation_curve data.table, curve of projected inflation with columns \code{date} and \code{proj_infl},
#'    eg can be generated by \link[InflationTools]{implied_proj_inflation_curve} 
#' @param ref_date date, the expected trade date, default to today
#' @param settle_convention numeric, the days until the instrument will be settled
#' @param inflation_lag numeric, the lag in months that instrument has to the inflation index 
#' @param interpolation character, can be daily or monthly, inflation interpolation method 
#'
#' @return a cashflow tibble with interpolated inflation indexes  
#' @importFrom magrittr %>%
#' @export
#'
#' @examples
#' 
#' temp_cashflow_tbl <- cashflow_table(as.Date("2023-02-21"), 0.1, 2)
#' interpolate_projected_inflation(temp_cashflow_tbl,
#'                                 exampleUSInflationCurve)
#' 
#' 
interpolate_projected_inflation <- function(cashflow_table,
                                            projected_inflation_curve,
                                            ref_date = Sys.Date(),
                                            settle_convention = 1,
                                            inflation_lag = 3,
                                            interpolation = "daily"){
  
  if (!all(c("date", "proj_infl") %in% colnames(projected_inflation_curve))) {
    futile.logger::flog.error("inflation data must have colnames: 'proj_infl', 'date'")
  }
  if(!(interpolation %in% c("daily", "monthly"))){
    futile.logger::flog.error(paste0(interpolation, " method not supported can be monthly or daily."))
  }
  
  # lag the projected inflation curve 
  projected_inflation_curve <- InflationTools::lag_inflation_curve(inflation_curve = projected_inflation_curve, 
                                                                   inflation_lag = inflation_lag)
  

    proj_infl <- tibble::enframe(sapply(cashflow_table$cashflow_date, 
                                        function(xout){
                                          InflationTools::interpolate_inflation_curve(
                                            projected_inflation_curve = projected_inflation_curve,
                                            ref_date = xout,
                                            inflation_lag = inflation_lag,
                                            settle_convention = settle_convention,
                                            round_5 = TRUE,
                                            interpolation = interpolation
                                          )
                                        }
    ),
    value = "proj_infl",
    name = NULL)
  
  
  base_factor <- stats::approx(projected_inflation_curve$date, 
                        projected_inflation_curve$season_factor_cuml, 
                        xout = (ref_date + settle_convention - 1))$y
  
  proj_infl_factor <- tibble::enframe(sapply(cashflow_table$cashflow_date, 
                                             function(xout){stats::approx(projected_inflation_curve$date, 
                                                                          projected_inflation_curve$season_factor_cuml, 
                                                                          xout = (xout + settle_convention))$y
                                             }
  ),
  value = "sa_factor",
  name = NULL) %>%
    dplyr::mutate(sa_factor = sa_factor / base_factor)
  
  
  data <-  proj_infl %>%
    cbind(proj_infl_factor)
  
  return(data)
  
}

#' Inflation linked bond cashflow table generator
#'
#' @description Adjusts the cashflows from \code{cashflow_table} for an inputted projected inflation curve. Also accounts
#'     for floors on the principal and coupon. 
#'
#' @param cashflow_table data.table, table of cashflows and discount periods, can be generated by \code{cashflow_table}
#' @param projected_inflation_curve data.table, curve of projected inflation can be generated by \code{implied_proj_inflation_curve} 
#' @param ref_date date, the expected trade date, default to today
#' @param settle_convention numeric, the days until the instrument will be settled
#' @param inflation_lag numeric, the lag in months that instrument has to the inflation index 
#' @param reference_cpi numeric, the reference value of the inflation linked bond at issue 
#' @param principal_floor numeric, the percentage floor of the principal, eg 100 is floored at par
#' @param coupon_floor numeric, the percentage floor of the coupon, eg 0 is not floored
#'
#' @return a tibble of both inflation adjusted and unadjusted cashflows with discount periods
#' @importFrom magrittr %>%
#' @export
#'
#' @examples
#' temp_cashflow_tbl <- cashflow_table(as.Date("2023-02-21"), 0.1, 2)
#' linker_cashflow_table(temp_cashflow_tbl,
#'                       exampleUSInflationCurve,
#'                       260)
#'                                 
#'                                 
#'                                 
linker_cashflow_table <- function(cashflow_table,
                                  projected_inflation_curve,
                                  reference_cpi,
                                  ref_date = Sys.Date(),
                                  settle_convention = 1,
                                  inflation_lag = 3,
                                  principal_floor = 100,
                                  coupon_floor = 0){
  
  proj_infl <- InflationTools::interpolate_projected_inflation(cashflow_table = cashflow_table,
                                               projected_inflation_curve = projected_inflation_curve,
                                               ref_date = ref_date,
                                               settle_convention = settle_convention,
                                               inflation_lag = inflation_lag)
  
  cashflow_table <- cashflow_table %>%
    cbind(proj_infl) %>%
    dplyr::mutate(inflation_ref_index = round(proj_infl / reference_cpi, 5),
                  adjusted_interest = unadjusted_interest * pmax(inflation_ref_index, coupon_floor / 100),
                  adjusted_principal = unadjusted_principal * pmax(inflation_ref_index, principal_floor / 100),
                  adjusted_cashflow = adjusted_interest + adjusted_principal) 
  
  return(cashflow_table)
  
}



#' Accrued interest calculation (real / inflation unadjusted)
#' 
#' @description Calculate the interest accrued by an instrument since the last cashflow. This is the 
#'     real (inflation unadjusted) accrued. 
#'
#' @param cashflow_table data.table, table of cashflows and discount periods, can be generated by \code{cashflow_table} or \code{linker_cashflow_table}
#'
#' @return numeric, interest accrued on the instrument
#' @export
#'
#' @examples
#' cash_tbl <- cashflow_table(as.Date("2023-02-21"), 0.1, 2)
#' real_accrued(cash_tbl)
#' 
real_accrued <- function(cashflow_table){
  
  # use the cashflow table to calculate the accrued interest in the current period
  real_accrued <- cashflow_table$unadjusted_interest[1] * (cashflow_table$period_denominator[1] - cashflow_table$period_numerator[1]) / cashflow_table$period_denominator[1]
  
  return(real_accrued)
  
}



#' Real (or clean) price calculation
#'
#' @description Calculate the real (clean) price of a bond based on a the cashflows and real yield. 
#' 
#' @param cashflow_table data.table, table of cashflows and discount periods, can be generated by \code{cashflow_table}
#' @param real_yield numeric, real yield of instrument at reference date
#' @param payment_frequency numeric, payment frequency per annum of the instrument eg 2 is semi-annual
#' @param real_accrued numeric,interest accrued by an instrument since the last cashflow, can be generated by \code{real_accrued}
#'
#' @return numeric, the clean (or real) price of the instrument 
#' @export
#'
#' @examples
#' cash_tbl <- cashflow_table(as.Date("2023-02-21"), 0.1, 2)
#' real_price(cash_tbl, 
#'             real_yield = -1,
#'             payment_frequency = 1,
#'             real_accrued = 1000)
#' 
real_price <- function(cashflow_table,
                        real_yield,
                        payment_frequency,
                        real_accrued){
  
  # Generate the real_yield discounted cashflow table and then sum to get the real or clean price 
  real_price <- cashflow_table %>%
    dplyr::mutate(real_cashflow_value = unadjusted_cashflow / ((1 + (real_yield / (100 * payment_frequency))) ^ discount_period_fraction)) %>%
    dplyr::summarise(price = 100 * (sum(real_cashflow_value) - real_accrued) / 1000000) %>%
    dplyr::pull(price)
  
  return(real_price)
  
}


#' Calculate seasonally adjusted real yield
#'
#' @description Calculate the seasonally adjusted real yield of an inflation linked instrument. Requires a cashflow table, a projected inflation
#'     curve and the seasonally adjusted factors (multiplicative). These can be generated using a combination of functions such as 
#'     \link[InflationTools]{linker_cashflow_table} and \link[InflationTools]{implied_proj_inflation_curve_db}.   
#'
#' @param linker_cashflow_table data.table, table of inflation linked (adjusted) cashflows and discount periods, can be generated by 
#'    \link[InflationTools]{linker_cashflow_table}.
#' @param real_price numeric, the real (or clean price) of an inflation linked bond
#' @param payment_frequency numeric, payment frequency per annum of the instrument eg 2 is semi-annual
#' @param real_accrued numeric,interest accrued by an instrument since the last cashflow, can be generated by \link[InflationTools]{real_accrued}.
#'
#' @return numeric, a real yield 
#' @export
#'
#' @examples
#' temp_cashflow_tbl <- cashflow_table(as.Date("2023-02-21"), 0.1, 2)
#' linker_cash_tbl <- linker_cashflow_table(temp_cashflow_tbl,
#'                                          exampleUSInflationCurve,
#'                                          260)
#' seasonally_adjusted_real_yield(linker_cash_tbl,
#'                                145,
#'                                2,
#'                                2500)                
#'                          
#' 
#' 
seasonally_adjusted_real_yield <- function(linker_cashflow_table, 
                                           real_price,
                                           payment_frequency, 
                                           real_accrued){
  
  # create a function which then can be optimised over to find the yield based on the price
  # see Markets 1621586 in filesite for an overview of seasonal adjustment
  real_function_sa <- function(real_yield_func){
    
    adj_real_price <- linker_cashflow_table %>%
      dplyr::mutate(real_cashflow_value = (unadjusted_cashflow / sa_factor) / ((1 + (real_yield_func / (100 * payment_frequency))) ^ discount_period_fraction)) %>%
      dplyr::summarise(price = (sum(real_cashflow_value) - real_accrued) / 10000) %>%
      dplyr::pull(price)
    
    output <- adj_real_price - real_price
    
    abs(as.numeric(output))
    
  }
  
  # optimise over the the function, low tolerance should not have very large calculation time due to simple nature of calculation
  real_yield_sa <- stats::optimise(f = real_function_sa, 
                                    interval = c(-20, 20), 
                                    tol = 0.0000000001
                                   )$minimum
  
  return(real_yield_sa)
  
}


#' Calculate real yield
#'
#' @description Calculate the yield (or real yield) of an instrument. Requires a cashflow table.
#'  
#' @param cashflow_table data.table, table of cashflows and discount periods, can be generated by \link[InflationTools]{cashflow_table}.
#' @param real_price numeric, the real (or clean price) of an inflation linked bond
#' @param payment_frequency numeric, payment frequency per annum of the instrument eg 2 is semi-annual
#' @param real_accrued numeric,interest accrued by an instrument since the last cashflow, can be generated by \link[InflationTools]{real_accrued}.
#'
#' @return numeric, a yield 
#' @export
#'
#' @examples
#' temp_cashflow_tbl <- cashflow_table(as.Date("2023-02-21"), 0.1, 2)
#' real_yield(temp_cashflow_tbl,
#'                          145,
#'                          2,
#'                          2500)                
#'                          
#' 
#' 
real_yield <- function(cashflow_table, 
                          real_price,
                          payment_frequency, 
                          real_accrued){
  
  # create a function which then can be optimised over to find the yield based on the price
  real_function <- function(real_yield){
    
    adj_real_price <- cashflow_table %>%
      dplyr::mutate(real_cashflow_value = (unadjusted_cashflow) / ((1 + (real_yield / (100 * payment_frequency))) ^ discount_period_fraction)) %>%
      dplyr::summarise(price = (sum(real_cashflow_value) - real_accrued) / 10000) %>%
      dplyr::pull(price)
    
    output <- adj_real_price - real_price
    
    abs(as.numeric(output))
    
  }
  
  # optimise over the the function, low tolerance should not have very large calculation time due to simple nature of calculation
  real_yield <- stats::optimise(f = real_function, 
                                   interval = c(-20, 20), 
                                   tol = 0.0000000001
                                )$minimum
  
  return(real_yield)
  
}


#' Calculate nominal equivalent yield for a linker
#' 
#' @description For an inflation linked bond, calculates, based on the project inflation curve, a nominal equivalent yield for 
#'    the inflation linked instrument. It does this by taking discounting the instruments cashflow after they have been adjusted 
#'    for projected inflation, is the same way you would calculate the yield of a nominal bond. The cashflow profile of the inflation
#'    linked instrument is skewed longer than a nominal comparitor but this shoudl not decrease the relevance of the results.  
#'
#' @param linker_cashflow_table data.table, table of inflation linked (adjusted) cashflows and discount periods, can be generated by 
#'    \link[InflationTools]{linker_cashflow_table}.
#' @param real_price numeric, the real (or clean price) of an inflation linked bond
#' @param payment_frequency numeric, payment frequency per annum of the instrument eg 2 is semi-annual
#' @param real_accrued numeric,interest accrued by an instrument since the last cashflow, can be generated by \link[InflationTools]{real_accrued}.
#' @param principal numeric, the principal of the /bond ie dirty proceeds less accrued  
#'
#' @return numeric, a yield
#' @export
#'
#' @examples
#' temp_cashflow_tbl <- cashflow_table(as.Date("2023-02-21"), 0.1, 2)
#' linker_cash_tbl <- linker_cashflow_table(temp_cashflow_tbl,
#'                                          exampleUSInflationCurve,
#'                                          260)
#' nominal_equivalent_yield(linker_cash_tbl,
#'                                145,
#'                                2,
#'                                2500, 
#'                                156000000)    
#'                                
nominal_equivalent_yield <- function(linker_cashflow_table, 
                                           real_price,
                                           payment_frequency, 
                                           real_accrued, 
                                           principal){
  
  nominal_function <- function(nominal_equiv_yield){
    
    adj_real_price <- linker_cashflow_table %>%
      dplyr::mutate(adj_cashflow_value = adjusted_cashflow / ((1 + (nominal_equiv_yield / (100 * payment_frequency))) ^ discount_period_fraction)) %>%
      dplyr::summarise(price = (sum(adj_cashflow_value) - real_accrued) / 10000) %>%
      dplyr::pull(price)
    
    output <- (adj_real_price * 10000) - principal
    
    abs(as.numeric(output))
    
  }
  
  nominal_yield <- stats::optimise(f = nominal_function, 
                                     interval = c(-20, 20), 
                                     tol = 0.0000000001
                                  )$minimum
  
  return(nominal_yield)
  
}


#' Calculate convexity for an inflation linked instrument 
#' 
#' @description Using the cashflows from an inflation linked instrument, calculate the the convexity (also known as the second derivative
#'     of the interest rate risk). 
#'
#' @param linker_cashflow_table data.table, table of inflation linked (adjusted) cashflows and discount periods, can be generated by 
#'    \link[InflationTools]{linker_cashflow_table}.
#' @param real_yield numeric, real yield of instrument at reference date
#' @param payment_frequency numeric, payment frequency per annum of the instrument eg 2 is semi-annual
#'
#' @return numeric, the convexity 
#' @export
#'
#' @examples
#' temp_cashflow_tbl <- cashflow_table(as.Date("2023-02-21"), 0.1, 2)
#' linker_cash_tbl <- linker_cashflow_table(temp_cashflow_tbl,
#'                                          exampleUSInflationCurve,
#'                                          260)
#' convexity_inflation(linker_cash_tbl,
#'                                -1,
#'                                2)
#'                                
#'                                    
convexity_inflation <- function(linker_cashflow_table, 
                                real_yield,
                                payment_frequency){
  
  # Similar to the DV01 calculations the convexity calculation uses the standar formula
  convexity <- linker_cashflow_table %>%
    dplyr::mutate(adj_cashflow_value = adjusted_cashflow / ((1 + (real_yield / (100 * payment_frequency))) ^ discount_period_fraction),
                  conv_col = adj_cashflow_value * (discount_period_fraction / payment_frequency) * ((discount_period_fraction / payment_frequency) + 1)
                  ) %>%
    dplyr::summarise(temp = (sum(adj_cashflow_value)),
                     temp2 = sum(conv_col),
                     temp3 = ((sum(adj_cashflow_value) * (1 + (real_yield / (payment_frequency * 100))) ^ 2)),
                     convx = sum(conv_col) / ((sum(adj_cashflow_value) * (1 + (real_yield / (payment_frequency * 100))) ^ 2))) %>%
    dplyr::pull(convx)
  
  return(convexity)
  
}



#' Calculate Macauley duration for an inflation linked instrument 
#' 
#' @description Using the cashflows from an inflation linked instrument, calculate the the convexity (also known as the second derivative
#'     of the interest rate risk). 
#'
#' @param linker_cashflow_table data.table, table of inflation linked (adjusted) cashflows and discount periods, can be generated by 
#'    \link[InflationTools]{linker_cashflow_table}.
#' @param real_yield numeric, real yield of instrument at reference date
#' @param payment_frequency numeric, payment frequency per annum of the instrument eg 2 is semi-annual
#'
#' @return numeric, the macauley duration 
#'
#' @export
#'
#' @examples
#' temp_cashflow_tbl <- cashflow_table(as.Date("2023-02-21"), 0.1, 2)
#' linker_cash_tbl <- linker_cashflow_table(temp_cashflow_tbl,
#'                                          exampleUSInflationCurve,
#'                                          260)
#' duration_mac_inflation (linker_cash_tbl,
#'                                -1,
#'                                2)
#' 
#' 
duration_mac_inflation <- function(linker_cashflow_table,
                                   real_yield, 
                                   payment_frequency){
  
  mac_dur <- linker_cashflow_table %>%
    dplyr::mutate(adj_cashflow_value = adjusted_cashflow / ((1 + (real_yield / (100 * payment_frequency))) ^ discount_period_fraction),
                  mac_test = adj_cashflow_value * (discount_period_fraction / payment_frequency), 
                  mac_dur_col = (adjusted_cashflow / ((1 + (real_yield / (100 * payment_frequency))) ^ discount_period_fraction) * (discount_period_fraction / payment_frequency))) %>%
    dplyr::summarise(macdur = sum(mac_dur_col) / sum(adj_cashflow_value)) %>%
    dplyr::pull(macdur)
  
  return(mac_dur)
  
}



#' Lagged reference date for interpolation 
#' 
#' @description For an instrument using standard inflation lag, gives the interpolation date based on
#'   the input date, lag and interpolation method. 
#'  
#' 
#' @param ref_date date, the date to be lagged
#' @param settle_convention numeric, the days until the instrument will be settled
#' @param inflation_lag numeric, the lag in months that instrument has to the inflation index 
#' @param interpolation character, can be \code{daily} or \code{monthly}, inflation interpolation method 
#'
#' @return date
#' @importFrom magrittr %>%
#' @importFrom lubridate %m-%
#' @export
#'
#' @examples
#' 
#' interpolation_reference_date(as.Date("2027-02-21"))
#' interpolation_reference_date(as.Date("2032-07-15"),
#'                              interpolation = "monthly")
#' 
#' 
#' 
interpolation_reference_date <- function(ref_date,
                                         settle_convention = 1,
                                         inflation_lag = 3,
                                         interpolation = "daily"){
  
  if(!(interpolation %in% c("daily", "monthly"))){
    futile.logger::flog.error(paste0(interpolation, " interpolation method not supported can be monthly or daily."))
  }
  
  
  if(interpolation == "daily"){
    new_date <- ref_date %m-% months(inflation_lag - 1) + settle_convention - 1
  }else if(interpolation == "monthly"){
    new_date <- as.Date(paste(
      lubridate::year((ref_date - 1) %m-% months(1)),
      lubridate::month((ref_date - 1) %m-% months(1)),
      "01",
      sep = "-"
      )
      ) - 1
  }
  
  return(new_date)
  
}



